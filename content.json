{"meta":{"title":"KillerXu的博客","subtitle":"che dan articles","description":null,"author":"KillerXu","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"题解 P2112 【鸿雁传书】","slug":"hongyanchuanshu","date":"2019-03-15T13:05:00.000Z","updated":"2019-03-15T13:07:12.542Z","comments":true,"path":"2019/03/15/hongyanchuanshu/","link":"","permalink":"http://yoursite.com/2019/03/15/hongyanchuanshu/","excerpt":"","text":"既然不能把情书中的单词拆开，那么每个单词就是独立的，我们只要去探究每个单词的长度，换行我们直接理解为分段就可以了。 于是题意其实就是给出一个有$n$个数的数列，将这个数列分成$k$段，使每一段所有数的总和方差最小。 这道题我们考虑dp，显然我们的子问题就是把前$i$个数分成$j$段，每一段所有数的总和方差最小，状态应由$i$前面所有的数分成$j-1$段的最好结果转移过来。 可以写出转移方程了： 设$f[i][j]$表示前$i$个数分成$j$段，最小的每一段所有数总和的方差。 $f[i][j]=min(f[i][j],f[l][j-1]+sum(i,l))$ 其中$1≤l≤i-1$,$sum(i,l)$表示从$i$到$l$这一段数的和减去平均数的平方再除以$k$，实际操作时可以用前缀和。答案最后在$f[n][k]$里。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 1005#define MAXK 105using namespace std;int n,k;double a[MAXN],f[MAXN][MAXK];//a[i]表示第i个单词的长度 double s[MAXN];//s是前缀和数组 int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); double ave=0;//记录平均数 for(int i=1;i&lt;=n;i++)&#123; char str[25]; scanf(\"%s\",str);//读入单词（全是x） a[i]=strlen(str);//记录单词长度 ave+=a[i];//累加起来好算平均数 s[i]=s[i-1]+a[i];//计算前缀和 &#125; ave/=k;//算出平均数 for(int i=1;i&lt;=n;i++) for(int j=2;j&lt;=k;j++) f[i][j]=0x7fffffff;//除了第一列，其他地方都初始化成最大值 for(int i=1;i&lt;=n;i++) f[i][1]=(s[i]-ave)*(s[i]-ave)/k;//分成一段的最小值直接计算出方差就行了 for(int j=2;j&lt;=k;j++)//分成一段不用处理了，直接从分成两段开始处理 for(int i=j;i&lt;=n;i++)//前面i个数最多也只能分成i段，所以如果j&gt;i就不行 for(int l=1;l&lt;=i-1;l++) f[i][j]=min(f[i][j],f[l][j-1]+(s[i]-s[l]-ave)*(s[i]-s[l]-ave)/k);//转移方程 printf(\"%.1lf\",f[n][k]);//输出即可 return 0;&#125;","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/默认分类/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"洛谷 P5248[LnOI2019SP]快速多项式变换(FPT) 代码","slug":"my-first-blog","date":"2019-03-14T14:04:00.000Z","updated":"2019-03-14T14:16:26.239Z","comments":true,"path":"2019/03/14/my-first-blog/","link":"","permalink":"http://yoursite.com/2019/03/14/my-first-blog/","excerpt":"","text":"本博客第一篇文章，对我而言意义重大。 暂时未添加LaTeX 这道题思路还是很简单的，从最大次幂向下模拟，每次尽可能取大的系数就可以了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;ll m,sum;ll a[200];ll pow(ll n,int x)&#123; if(x==0) return 1; ll sum=n; for(int i=2;i&lt;=x;i++) sum*=n; return sum;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;sum; ll maxn=m,k=1; while(maxn*m&lt;=sum)&#123; maxn*=m; k++; &#125; ll res=sum; cout&lt;&lt;k+1&lt;&lt;\"\\n\"; for(int i=k;i&gt;=0;i--)&#123; if(pow(m,i)&gt;res) continue; a[i]=res/pow(m,i); res-=a[i]*pow(m,i); //out&lt;&lt;a[i]&lt;&lt;\" \"&lt;&lt;res&lt;&lt;\"\\n\"; &#125; for(int i=0;i&lt;=k;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; return 0;&#125;","categories":[{"name":"默认分类","slug":"默认分类","permalink":"http://yoursite.com/categories/默认分类/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"枚举","slug":"枚举","permalink":"http://yoursite.com/tags/枚举/"}]}]}